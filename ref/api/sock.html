<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Sockets - NNG Reference Manual (DRAFT)</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/pagetoc.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">NNG Reference Manual (DRAFT)</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="sockets"><a class="header" href="#sockets">Sockets</a></h1>
<p>Sockets <a name="a001"></a> in Scalability Protocols provide the handle for communication
between peers. Sockets also encapsulate protocol specific semantics, such as
filtering subscriptions, or automatically retrying requests.</p>
<h2 id="socket-structure"><a class="header" href="#socket-structure">Socket Structure</a></h2>
<pre><code class="language-c">#define NNG_SOCKET_INITIALIZER // opaque value

typedef struct nng_socket_s nng_socket;
</code></pre>
<p>The <a name="a002"></a><code>nng_socket</code> structure represents socket. This is a handle, and
the members of it are opaque. However, unlike a pointer, it is usually
passed by value.</p>
<p>A socket may be initialized statically with the <code>NNG_SOCKET_INITIALIZER</code> macro,
to ensure that it cannot be confused with a valid open socket.</p>
<h2 id="socket-identity"><a class="header" href="#socket-identity">Socket Identity</a></h2>
<pre><code class="language-c">int nng_socket_id(nng_socket s);
int nng_socket_raw(nng_socket s, bool *raw);
int nng_socket_proto_id(nng_socket s, uint16_t *proto);
int nng_socket_peer_id(nng_socket s, uint16_t *proto);
int nng_socket_proto_name(nng_socket s, const char **name);
int nng_socket_peer_name(nng_socket s, const char **name);
</code></pre>
<p>These functions are used to provide fundamental information about the socket <em>s</em>.
Most applications will not need to use these functions.</p>
<p>The <a name="a003"></a><code>nng_socket_id</code> function returns the numeric id, which will be a non-negative
value, associated with the socket. If the socket is uninitialized (has never been opened),
then the return value may be <code>-1</code>.</p>
<p>The <a name="a004"></a><code>nng_socket_proto_id</code> and <a name="a005"></a><code>nng_socket_peer_id</code> functions provide the 16-bit
protocol identifier for the socket’s protocol, and of the protocol peers will use when
communicating with the socket.</p>
<p>The <a name="a006"></a><code>nng_socket_proto_name</code> and <a name="a007"></a><code>nng_socket_peer_name</code> functions provide the ASCII
names of the socket’s protocol, and of the protocol peers of the socket use.
The value stored in <em>name</em> is a fixed string located in program text, and must not be freed
or altered. It is guaranteed to remain valid while this library is present.</p>
<p>The <a name="a008"></a><code>nng_socket_raw</code> function determines whether the socket is in
<a href="/api/sock.html#raw-mode-sockets">raw mode</a> or not, storing <code>true</code> in <em>raw</em> if it is, or <code>false</code> if it is not.</p>
<h2 id="opening-a-socket"><a class="header" href="#opening-a-socket">Opening a Socket</a></h2>
<pre><code class="language-c">int nng_bus0_open(nng_socket *s);
int nng_pub0_open(nng_socket *s);
int nng_pull0_open(nng_socket *s);
int nng_push0_open(nng_socket *s);
int nng_rep0_open(nng_socket *s);
int nng_req0_open(nng_socket *s);
int nng_respondent0_open(nng_socket *s);
int nng_sub0_open(nng_socket *s);
int nng_surveyor0_open(nng_socket *s);
</code></pre>
<p>These functions open a socket, returning it in <em>s</em>.
The constructors for sockets are protocol specific so please refer to protocol documentation
for more specific information.</p>
<p>The following functions open a socket in normal mode:</p>
<ul>
<li><a name="a009"></a><code>nng_bus0_open</code> - <a href="/proto/bus.html">BUS</a> version 0</li>
<li><a name="a010"></a><code>nng_pair0_open</code> - <a href="/proto/pair.html">PAIR</a> version 0</li>
<li><a name="a011"></a><code>nng_pair1_open</code> - <a href="/proto/pair.html">PAIR</a> version 1</li>
<li><a name="a012"></a><code>nng_pair1_open_poly</code> - <a href="/proto/pair.html">PAIR</a> version 1, <a href="/proto/pair.html#polyamorous-mode">polyamorous</a> mode</li>
<li><a name="a013"></a><code>nng_pub0_open</code> - <a href="/proto/pub.html">PUB</a> version 0</li>
<li><a name="a014"></a><code>nng_pull0_open</code> - <a href="/proto/pull.html">PULL</a> version 0</li>
<li><a name="a015"></a><code>nng_push0_open</code> - <a href="/proto/push.html">PUSH</a> version 0</li>
<li><a name="a016"></a><code>nng_rep0_open</code> - <a href="/proto/rep.html">REP</a> version 0</li>
<li><a name="a017"></a><code>nng_req0_open</code> - <a href="/proto/req.html">REQ</a> version 0</li>
<li><a name="a018"></a><code>nng_respondent0_open</code> - <a href="/proto/respondent.html">RESPONDENT</a> version 0</li>
<li><a name="a019"></a><code>nng_sub0_open</code> - <a href="/proto/sub.html">SUB</a> version 0</li>
<li><a name="a020"></a><code>nng_surveyor0_open</code> - <a href="/proto/surveyor.html">SURVEYOR</a> version 0</li>
</ul>
<h2 id="raw-mode-sockets"><a class="header" href="#raw-mode-sockets">Raw Mode Sockets</a></h2>
<pre><code class="language-c">int nng_bus0_open_raw(nng_socket *s);
int nng_pub0_open_raw(nng_socket *s);
int nng_pull0_open_raw(nng_socket *s);
int nng_push0_open_raw(nng_socket *s);
int nng_rep0_open_raw(nng_socket *s);
int nng_req0_open_raw(nng_socket *s);
int nng_respondent0_open_raw(nng_socket *s);
int nng_sub0_open_raw(nng_socket *s);
int nng_surveyor0_open_raw(nng_socket *s);
</code></pre>
<p><a name="a021"></a>
Raw mode sockets are used in circumstances when the application needs direct access
to the message headers to control the protocol details.</p>
<p>Such sockets require greater sophistication on the part of the application to use,
as the application must process the protocol headers specifically.
The details of the protocol headers, and requirements, are described in the protocol
documentation for each protocol.</p>
<p>Raw mode sockets do not have any kind of state machine associated with them, as all of
the protocol specific processing must be performed by the application.</p>
<div class="mdbook-alerts mdbook-alerts-tip">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  tip
</p>
<p>Most applications do not need to use raw sockets.
The notable exception is when using <a href="/TODO.html"><code>nng_device</code></a>, which requires raw sockets.
To obtain asynchronous behavior, consider using <a href="/TODO.html">contexts</a> instead.</p>
</div>
<p>The following functions open a socket in <a href="/api/sock.html#raw-mode-sockets">raw</a> mode:</p>
<ul>
<li><a name="a022"></a><code>nng_bus0_open_raw</code> - <a href="/proto/bus.html">BUS</a> version 0, raw mode</li>
<li><a name="a023"></a><code>nng_pair0_open_raw</code> - <a href="/proto/pair.html">PAIR</a> version 0, raw mode</li>
<li><a name="a024"></a><code>nng_pair1_open_raw</code> - <a href="/proto/pair.html">PAIR</a> version 1, raw mode</li>
<li><a name="a025"></a><code>nng_pub0_open_raw</code> - <a href="/proto/pub.html">PUB</a> version 0, raw mode</li>
<li><a name="a026"></a><code>nng_pull0_open_raw</code> - <a href="/proto/pull.html">PULL</a> version 0, raw mode</li>
<li><a name="a027"></a><code>nng_push0_open_raw</code> - <a href="/proto/push.html">PUSH</a> version 0, raw mode</li>
<li><a name="a028"></a><code>nng_rep0_open_raw</code> - <a href="/proto/rep.html">REP</a> version 0, raw mode</li>
<li><a name="a029"></a><code>nng_req0_open_raw</code> - <a href="/proto/req.html">REP</a> version 0, raw mode</li>
<li><a name="a030"></a><code>nng_respondent0_open_raw</code> - <a href="/proto/respondent.html">RESPONDENT</a> version 0, raw mode</li>
<li><a name="a031"></a><code>nng_sub0_open_raw</code> - <a href="/proto/sub.html">SUB</a> version 0, raw mode</li>
<li><a name="a032"></a><code>nng_surveyor0_open_raw</code> - <a href="/proto/surveyor.html">SURVEYOR</a> version 0, raw mode</li>
</ul>
<h2 id="closing-a-socket"><a class="header" href="#closing-a-socket">Closing a Socket</a></h2>
<pre><code class="language-c">int nng_socket_close(nng_socket s);
</code></pre>
<p>The <a name="a033"></a><code>nng_socket_close</code> function closes a socket, releasing all resources
associated with it. Any operations that are in progress will be terminated with
a result of <a href="/api/errors.html#NNG_ECLOSED"><code>NNG_ECLOSED</code></a>.</p>
<div class="mdbook-alerts mdbook-alerts-note">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  note
</p>
<p>Closing a socket also invalidates any <a href="/TODO.html">dialers</a>, <a href="/TODO.html">listeners</a>,
<a href="/api/pipe.html">pipes</a>, or <a href="/TODO.html">contexts</a> associated with it.</p>
</div>
<div class="mdbook-alerts mdbook-alerts-note">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  note
</p>
<p>This function will wait for any outstanding operations to be aborted, or to complete,
before returning. Consequently it is not safe to call this from contexts that cannot
block.</p>
</div>
<div class="mdbook-alerts mdbook-alerts-note">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  note
</p>
<p>Closing the socket may be disruptive to transfers that are still in progress.</p>
</div>
<h2 id="sending-messages"><a class="header" href="#sending-messages">Sending Messages</a></h2>
<pre><code class="language-c">int nng_send(nng_socket s, void *data, size_t size, int flags);
int nng_sendmsg(nng_socket s, nng_msg *msg, int flags);
void nng_socket_send(nng_socket s, nng_aio *aio);
</code></pre>
<p>These functions (<a name="a034"></a><code>nng_send</code>, <a name="a035"></a><code>nng_sendmsg</code>, and <a name="a036"></a><code>nng_socket_send</code>) send
messages over the socket <em>s</em>. The differences in their behaviors are as follows.</p>
<div class="mdbook-alerts mdbook-alerts-note">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  note
</p>
<p>The semantics of what sending a message means varies from protocol to
protocol, so examination of the protocol documentation is encouraged.
Additionally, some protocols may not support sending at all or may require other pre-conditions first.
(For example, <a href="/proto/rep.html">REP</a> sockets cannot normally send data until they have first received a request,
while <a href="/proto/sub.html">SUB</a> sockets can only receive data and never send it.)</p>
</div>
<h3 id="nng_send"><a class="header" href="#nng_send">nng_send</a></h3>
<p>The <code>nng_send</code> function is the simplest to use, but is the least efficient.
It sends the content in <em>data</em>, as a message of <em>size</em> bytes. The <em>flags</em> is a bit mask
made up of zero or more of the following values:</p>
<ul>
<li><a name="a037"></a><code>NNG_FLAG_NONBLOCK</code>: <a name="NNG_FLAG_NONBLOCK"></a>
If the socket cannot accept more data at this time, it does not block, but returns immediately
with a status of <a href="/api/errors.html#NNG_EAGAIN"><code>NNG_EAGAIN</code></a>. If this flag is absent, the function will wait until data can be sent.</li>
</ul>
<div class="mdbook-alerts mdbook-alerts-note">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  note
</p>
<p>Regardless of the presence or absence of <code>NNG_FLAG_NONBLOCK</code>, there may
be queues between the sender and the receiver.
Furthermore, there is no guarantee that the message has actually been delivered.
Finally, with some protocols, the semantic is implicitly <code>NNG_FLAG_NONBLOCK</code>,
such as with <a href="/proto/pub.html">PUB</a> sockets, which are best-effort delivery only.</p>
</div>
<h3 id="nng_sendmsg"><a class="header" href="#nng_sendmsg">nng_sendmsg</a></h3>
<p>The <code>nng_sendmsg</code> function sends the <em>msg</em> over the socket <em>s</em>.</p>
<p>If this function returns zero, then the socket will dispose of <em>msg</em> when the transmission is complete.
If the function returns a non-zero status, then the call retains the responsibility for disposing of <em>msg</em>.</p>
<p>The <em>flags</em> can contain the value <a href="/TODO.html"><code>NNG_FLAG_NONBLOCK</code></a>, indicating that the function should not wait if the socket
cannot accept more data for sending. In such a case, it will return <a href="/api/errors.html#NNG_EAGAIN"><code>NNG_EAGAIN</code></a>.</p>
<div class="mdbook-alerts mdbook-alerts-tip">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  tip
</p>
<p>This function is preferred over <a href="/api/sock.html#nng_send"><code>nng_send</code></a>, as it gives access to the message structure and eliminates both
a data copy and allocation.</p>
</div>
<h3 id="nng_socket_send"><a class="header" href="#nng_socket_send">nng_socket_send</a></h3>
<p>The <code>nng_socket_send</code> function sends a message asynchronously, using the <a href="/api/aio.html#asynchronous-io-handle"><code>nng_aio</code></a> <em>aio</em>, over the socket <em>s</em>.
The message to send must have been set on <em>aio</em> using the <a href="/api/aio.html#messages"><code>nng_aio_set_msg</code></a> function.</p>
<p>If the operation completes successfully, then the socket will have disposed of the message.
However, if it fails, then callback of <em>aio</em> should arrange for a final disposition of the message.
(The message can be retrieved from <em>aio</em> with <a href="/api/aio.html#messages"><code>nng_aio_get_msg</code></a>.)</p>
<p>Note that callback associated with <em>aio</em> may be called <em>before</em> the message is finally delivered to the recipient.
For example, the message may be sitting in queue, or located in TCP buffers, or even in flight.</p>
<div class="mdbook-alerts mdbook-alerts-tip">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  tip
</p>
<p>This is the preferred function to use for sending data on a socket. While it does require a few extra
steps on the part of the application, the lowest latencies and highest performance will be achieved by using
this function instead of <a href="/api/sock.html#nng_send"><code>nng_send</code></a> or <a href="/api/sock.html#nng_sendmsg"><code>nng_sendmsg</code></a>.</p>
</div>
<h2 id="receiving-messages"><a class="header" href="#receiving-messages">Receiving Messages</a></h2>
<pre><code class="language-c">int nng_recv(nng_socket s, void *data, size_t *sizep, int flags);
int nng_recvmsg(nng_socket s, nng_msg **msgp, int flags);
void nng_socket_recv(nng_socket s, nng_aio *aio);
</code></pre>
<p>These functions (<a name="a038"></a><code>nng_recv</code>, <a name="a039"></a><code>nng_recvmsg</code>, and <a name="a040"></a><code>nng_socket_recv</code>) receive
messages over the socket <em>s</em>. The differences in their behaviors are as follows.</p>
<div class="mdbook-alerts mdbook-alerts-note">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  note
</p>
<p>The semantics of what receving a message means varies from protocol to
protocol, so examination of the protocol documentation is encouraged.
Additionally, some protocols may not support receiving at all or may require other pre-conditions first.
(For example, <a href="/proto/req.html">REQ</a> sockets cannot normally receive data until they have first sent a request,
while <a href="/proto/pub.html">PUB</a> sockets can only send data and never receive it.)</p>
</div>
<h3 id="nng_recv"><a class="header" href="#nng_recv">nng_recv</a></h3>
<p>The <code>nng_recv</code> function is the simplest to use, but is the least efficient.
It receives the content in <em>data</em>, as a message size (in bytes) of up to the value stored in <em>sizep</em>.</p>
<p>Upon success, the size of the message received will be stored in <em>sizep</em>.</p>
<p>The <em>flags</em> is a bit mask made up of zero or more of the following values:</p>
<ul>
<li><a name="a041"></a><code>NNG_FLAG_NONBLOCK</code>:
If the socket has no messages pending for reception at this time, it does not block, but returns immediately
with a status of <a href="/api/errors.html#NNG_EAGAIN"><code>NNG_EAGAIN</code></a>. If this flag is absent, the function will wait until data can be received.</li>
</ul>
<h3 id="nng_recvmsg"><a class="header" href="#nng_recvmsg">nng_recvmsg</a></h3>
<p>The <code>nng_recvmsg</code> function receives a message and stores a pointer to the <a href="/api/msg.html#message-structure"><code>nng_msg</code></a> for that message in <em>msgp</em>.</p>
<p>The <em>flags</em> can contain the value <a href="/TODO.html"><code>NNG_FLAG_NONBLOCK</code></a>, indicating that the function should not wait if the socket
has no messages available to receive. In such a case, it will return <a href="/api/errors.html#NNG_EAGAIN"><code>NNG_EAGAIN</code></a>.</p>
<div class="mdbook-alerts mdbook-alerts-tip">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  tip
</p>
<p>This function is preferred over <a href="/TODO.html"><code>nng_recv</code></a>, as it gives access to the message structure and eliminates both
a data copy and allocation.</p>
</div>
<h3 id="nng_socket_recv"><a class="header" href="#nng_socket_recv">nng_socket_recv</a></h3>
<p>The <code>nng_socket_send</code> function receives a message asynchronously, using the <a href="/api/aio.html#asynchronous-io-handle"><code>nng_aio</code></a> <em>aio</em>, over the socket <em>s</em>.
On success, the received message can be retrieved from the <em>aio</em> using the <a href="/api/aio.html#messages"><code>nng_aio_get_msg</code></a> function.</p>
<div class="mdbook-alerts mdbook-alerts-note">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  note
</p>
<p>It is important that the application retrieves the message, and disposes of it accordingly.
Failure to do so will leak the memory.</p>
</div>
<div class="mdbook-alerts mdbook-alerts-tip">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  tip
</p>
<p>This is the preferred function to use for receiving data on a socket. While it does require a few extra
steps on the part of the application, the lowest latencies and highest performance will be achieved by using
this function instead of <a href="/TODO.html"><code>nng_recv</code></a> or <a href="/api/sock.html#nng_recvmsg"><code>nng_recvmsg</code></a>.</p>
</div>
<h2 id="socket-options"><a class="header" href="#socket-options">Socket Options</a></h2>
<pre><code class="language-c">int nng_socket_get_bool(nng_socket s, const char *opt, bool *valp);
int nng_socket_get_int(nng_socket s, const char *opt, int *valp);
int nng_socket_get_ms(nng_socket s, const char *opt, nng_duration *valp);
int nng_socket_get_size(nng_socket s, const char *opt, size_t *valp);

int nng_socket_set_bool(nng_socket s, const char *opt, int val);
int nng_socket_set_int(nng_socket s, const char *opt, int val);
int nng_socket_set_ms(nng_socket s, const char *opt, nng_duration val);
int nng_socket_set_size(nng_socket s, const char *opt, size_t val);
</code></pre>
<p>Protocols usually have protocol specific behaviors that can be adjusted via options.</p>
<p>These functions are used to retrieve or change the value of an option named <em>opt</em> from the context <em>ctx</em>.
The <code>nng_socket_get_</code> functions retrieve the value from the socket <em>s</em>, and store it in the location <em>valp</em> references.
The <code>nng_socket_set_</code> functions change the value for the socket <em>s</em>, taking it from <em>val</em>.</p>
<p>These functions access an option as a specific type. The protocol documentation will have details about which options
are available, whether they can be read or written, and the appropriate type to use.</p>
<div class="mdbook-alerts mdbook-alerts-note">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  note
</p>
<p>Socket options are are used to tune the behavior of the higher level protocol. To change the options
for an underlying transport, the option should be set on the <a href="/TODO.html">dialer</a> or <a href="/TODO.html">listener</a> instead of the <a href="/TODO.html">socket</a>.</p>
</div>
<h3 id="common-options"><a class="header" href="#common-options">Common Options</a></h3>
<p>The following options are available for many protocols, and always use the same types and semantics described below.</p>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>NNG_OPT_MAXTTL</code><a name="NNG_OPT_MAXTTL"></a></td><td><code>int</code></td><td>Maximum number of traversals across an <a href="/TODO.html"><code>nng_device</code></a> device, to prevent forwarding loops. May be 1-255, inclusive. Normally defaults to 8.</td></tr>
<tr><td><code>NNG_OPT_RECONNMAXT</code><a name="NNG_OPT_RECONNMAXT"></a></td><td><code>nng_duration</code></td><td>Maximum time <a href="/TODO.html">dialers</a> will delay before trying after failing to connect.</td></tr>
<tr><td><code>NNG_OPT_RECONNMINT</code><a name="NNG_OPT_RECONNMINT"></a></td><td><code>nng_duration</code></td><td>Minimum time <a href="/TODO.html">dialers</a> will delay before trying after failing to connect.</td></tr>
<tr><td><code>NNG_OPT_RECVBUF</code><a name="NNG_OPT_RECVBUF"></a></td><td><code>int</code></td><td>Maximum number of messages (0-8192) to buffer locally when receiving.</td></tr>
<tr><td><code>NNG_OPT_RECVMAXSZ</code><a name="NNG_OPT_RECVMAXSZ"></a></td><td><code>size_t</code></td><td>Maximum message size acceptable for receiving. Zero means unlimited. Intended to prevent remote abuse. Can be tuned independently on <a href="/TODO.html">dialers</a> and <a href="/TODO.html">listeners</a>.</td></tr>
<tr><td><code>NNG_OPT_RECVTIMEO</code><a name="NNG_OPT_RECVTIMEO"></a></td><td><code>nng_duration</code></td><td>Default timeout (ms) for receiving messages.</td></tr>
<tr><td><code>NNG_OPT_SENDBUF</code><a name="NNG_OPT_SENDBUF"></a></td><td><code>int</code></td><td>Maximum number of messages (0-8192) to buffer when sending messages.</td></tr>
<tr><td><code>NNG_OPT_SENDTIMEO</code><a name="NNG_OPT_SENDTIMEO"></a></td><td><code>nng_duration</code></td><td>Default timeout (ms) for sending messages.</td></tr>
</tbody></table>
</div>
<p> </p>
<div class="mdbook-alerts mdbook-alerts-note">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  note
</p>
<p>The <code>NNG_OPT_RECONNMAXT</code>, <code>NNG_OPT_RECONNMINT</code>, and <code>NNG_OPT_RECVMAXSZ</code> options are just the initial defaults that <a href="/TODO.html">dialers</a>
(and for <code>NNG_OPT_RECVMAXSZ</code> also <a href="/TODO.html">listeners</a>)
will use. After the dialer or listener is created, changes to the socket’s value will have no affect on that dialer or listener.</p>
</div>
<h2 id="polling-socket-events"><a class="header" href="#polling-socket-events">Polling Socket Events</a></h2>
<pre><code class="language-c">int nng_socket_get_recv_poll_fd(nng_socket s, int *fdp);
int nng_socket_get_send_poll_fd(nng_socket s, int *fdp);
</code></pre>
<p>Sometimes it is necessary to integrate a socket into a <code>poll</code> or <code>select</code> driven
<a name="a042"></a>event loop. (Or, on Linux, <code>epoll</code>, or on BSD derived systems like macOS <code>kqueue</code>).</p>
<p>For these occasions, a suitable file descriptor for polling is provided
by these two functions.</p>
<p>The <a name="a043"></a><code>nng_socket_get_recv_poll_fd</code> function obtains a file descriptor
that will poll as readable when a message is ready for receiving for the socket.</p>
<p>The <a name="a044"></a><code>nng_socket_get_send_poll_fd</code> function obtains a file descriptor
that will poll as readable when the socket can accept a message for sending.</p>
<p>These file descriptors should only be polled for readability, and no
other operation performed on them. The socket will read from, or write to,
these file descriptors to provide a level-signaled behavior automatically.</p>
<p>Additionally the socket will close these file descriptors when the socket itself is closed.</p>
<p>These functions replace the <code>NNG_OPT_SENDFD</code> and <code>NNG_OPT_RECVFD</code> socket options that
were available in previous versions of NNG.</p>
<div class="mdbook-alerts mdbook-alerts-note">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  note
</p>
<p>These functions are not compatible with <a href="/TODO.html">contexts</a>.</p>
</div>
<div class="mdbook-alerts mdbook-alerts-note">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  note
</p>
<p>The file descriptors supplied by these functions is not used for transporting message data.
The only valid use of these file descriptors is for polling for the ability to send or receive
messages on the socket.</p>
</div>
<div class="mdbook-alerts mdbook-alerts-tip">
<p class="mdbook-alerts-title">
  <span class="mdbook-alerts-icon"></span>
  tip
</p>
<p>Using these functions will force the socket to perform extra system calls, and thus
have a negative impact on performance and latency. It is preferable to use <a href="/api/aio.html">asynchronous I/O</a>
when possible.</p>
</div>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h3 id="example-1-initializing-a-socket"><a class="header" href="#example-1-initializing-a-socket">Example 1: Initializing a Socket</a></h3>
<pre><code class="language-c">nng_socket s = NNG_SOCKET_INITIALIZER;
</code></pre>
<h3 id="example-2-publishing-a-timestamp"><a class="header" href="#example-2-publishing-a-timestamp">Example 2: Publishing a Timestamp</a></h3>
<p>This example demonstrates the use of <a href="/api/aio.html#asynchronous-io-handle"><code>nng_aio</code></a>, <a href="/api/sock.html#nng_socket_send"><code>nng_socket_send</code></a>, and <a href="/api/time.html"><code>nng_sleep_aio</code></a> to
build a service that publishes a timestamp at one second intervals. Error handling is elided for the
sake of clarity.</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;nng/nng.h&gt;
#include &lt;nng/protocol/pubsub0/pub.h&gt;

struct state {
    nng_socket s;
    bool sleeping;
    nng_aio *aio;
};

static struct state state;

void callback(void *arg) {
    nng_msg *msg;
    nng_time now;
    struct state *state = arg;
    if (nng_aio_result(state-&gt;aio) != 0) {
        fprintf(stderr, "Error %s occurred", nng_strerror(nng_aio_result(state-&gt;aio)));
        return; // terminate the callback loop
    }
    if (state-&gt;sleeping) {
        state-&gt;sleeping = false;
        nng_msg_alloc(&amp;msg, sizeof (nng_time));
        now = nng_clock();
        nng_msg_append(msg, &amp;now, sizeof (now)); // note: native endian
        nng_aio_set_msg(state-&gt;aio, msg);
        nng_socket_send(state-&gt;s, state-&gt;aio);
    } else {
        state-&gt;sleeping = true;
        nng_sleep_aio(1000, state-&gt;aio); // 1000 ms == 1 second
    }
}

int main(int argc, char **argv) {
    const char *url = argv[1]; // should check this

    nng_aio_alloc(&amp;state.aio, NULL, NULL);
    nng_pub0_open(&amp;state.s);
    nng_listen(state.s, url, NULL, 0);
    state.sleeping = 0;
    nng_sleep_aio(1, state.aio); // kick it off right away
    for(;;) {
        nng_msleep(0x7FFFFFFF); // infinite, could use pause or sigsuspend
    }
}
</code></pre>
<h3 id="example-3-watching-a-periodic-timestamp"><a class="header" href="#example-3-watching-a-periodic-timestamp">Example 3: Watching a Periodic Timestamp</a></h3>
<p>This example demonstrates the use of <a href="/api/aio.html#asynchronous-io-handle"><code>nng_aio</code></a>, <a href="/api/sock.html#nng_socket_recv"><code>nng_socket_recv</code></a>, to build a client to
watch for messages received from the service created in Example 2.
Error handling is elided for the sake of clarity.</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;&gt;
#include &lt;nng/nng.h&gt;
#include &lt;nng/protocol/pubsub0/sub.h&gt;

struct state {
    nng_socket s;
    nng_aio *aio;
};

static struct state state;

void callback(void *arg) {
    nng_msg *msg;
    nng_time now;
    struct state *state = arg;
    if (nng_aio_result(state-&gt;aio) != 0) {
        fprintf(stderr, "Error %s occurred", nng_strerror(nng_aio_result(state-&gt;aio)));
        return; // terminate the callback loop
    }
    msg = nng_aio_get_msg(state-&gt;aio);
    memcpy(&amp;now, nng_msg_body(msg), sizeof (now)); // should check the length!
    printf("Timestamp is %lu\n", (unsigned long)now);
    nng_msg_free(msg);
    nng_aio_set_msg(state-&gt;aio, NULL);
    nng_socket_recv(state-&gt;s, state-&gt;aio);
}

int main(int argc, char **argv) {
    const char *url = argv[1]; // should check this

    nng_aio_alloc(&amp;state.aio, NULL, NULL);
    nng_sub0_open(&amp;state.s);
    nng_sub0_socket_subscribe(state.s, NULL, 0); // subscribe to everything
    nng_dial(state.s, url, NULL, 0);
    nng_socket_recv(state.s, state.aio); // kick it off right away
    for(;;) {
        nng_msleep(0x7FFFFFFF); // infinite, could use pause or sigsuspend
    }
}
</code></pre>
<!-- Symbol cross reference -->
<!-- HTTP -->
<!-- Macros -->
<!-- Protocols -->
<!-- Transports -->
<!-- Concept index -->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../api/msg.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../api/ctx.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../api/msg.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../api/ctx.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/pagetoc.js"></script>


    </div>
    </body>
</html>
